# 5.5 Database Backend

---

## Overview
Our application uses **SQLite**, a lightweight database that doesn't require a separate server. It's a simple and fast way to store data directly in a file on the server.

## Why Use SQLite?
SQLite is a great choice because:
- It’s **self-contained**, meaning we don't need an external server for it to work.
- It's **easy to set up** with no complex configuration.
- It's efficient and handles our user load well without slowing down.

## Database Structure
The database contains three key tables to manage the main data:

1. **Users**: Stores information about each user, such as their username, email, password, and other settings like their online status or profile picture.

2. **Matches**: Keeps track of game matches, including players, scores, and who won the match.

3. **Friendships**: Manages user relationships, such as friends and friend requests, including the status of those friendships (e.g., pending, accepted).

### Simple Query Example
Imagine we want to find a user by their username or email. The database would look for the matching details and return the user's information. This helps us authenticate users when they log in or update their profiles.

---

## How Data Is Managed

### User Authentication
When a user logs in, their username or email is checked against the **users** table. If the details match, they’re logged in. We also check their online status to update it.

### Friend Management
To manage friendships, the **friendships** table is used. It tracks who is friends with whom and the current status of the friendship. When users send or accept friend requests, the status in the table is updated accordingly.

### Game History
For every match played, the **matches** table records details such as the players, scores, and the winner. This helps us store and display game statistics.

---

## Data Flow
When the application needs to access or update data, it follows this simple flow:
1. **Frontend**: The user requests an action (e.g., logging in, viewing game history).
2. **Backend**: The backend processes the request, checking user details or retrieving data from the database.
3. **Database**: The backend interacts with SQLite to fetch or update information.
4. **Frontend**: The user sees the updated data or a success message on their screen.

---

## Transactions
Some actions may require multiple updates to the database, like when a new match is played and several tables need to be updated. These actions are handled in **transactions** to ensure all changes are successful, or if something goes wrong, no changes are made.

---

## Simple Database Queries

Here are some examples of simple operations we perform with the database:

- **User Lookup**: Find a user by their username or email.
- **Match History**: Retrieve a list of past games for a user, including the players and the winner.
- **Friendship Status**: Check the status of a user's friendships and send requests when necessary.

---

## Error Handling
If something goes wrong while interacting with the database, the application handles it gracefully with clear error messages, such as:
- **Bad Request (400)**: Invalid input, like an incorrect email format.
- **Unauthorized (401)**: Wrong credentials, like an incorrect password.
- **Not Found (404)**: When the requested user or match doesn't exist.
- **Server Errors (500)**: Internal issues like database connection problems.

---

## Conclusion
SQLite is a simple yet powerful choice for managing the application's data. It ensures smooth user interactions, handles friendships, and tracks game statistics efficiently. The application follows a clear structure to keep the code organized and maintainable, making it easy to extend or change if needed.

--- 
